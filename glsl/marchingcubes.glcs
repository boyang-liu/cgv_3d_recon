#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, r32f) uniform readonly image3D Vertices_tex;


layout (std430, binding = 3) buffer tablesBuffer
{
     int edgeTable[256];
     int triTable[256][16];
};

layout (std430, binding = 5) buffer trianglesBuffer// coherent
{
    int triCount;
	float triangles[];

    
	//int cnts[];
	
};


// currently processed cube data
struct ControlNode
{
    vec3 pos;
    float value;
};

uniform ivec3 vereticesGridDims;
uniform ivec3 cubeGridDims;
uniform float surfaceLevel;
uniform vec3 min_pos;
uniform vec3 max_pos;



//vertex node
ControlNode controlNodes[8];
//edge node
vec3 edgeNodes[12];
int configuration = 0;



int indexPoint(int x, int y, int z){
    return x + vereticesGridDims.x * y + vereticesGridDims.x * vereticesGridDims.y * z;
}

int indexCube(int x, int y, int z){
    return (x + cubeGridDims.x * y + cubeGridDims.x * cubeGridDims.y * z) ;//* 13
}

ControlNode getControlNode(int x, int y, int z){

    //int i = indexPoint(x, y, z);
	vec3 boundingbox_size=(max_pos-min_pos);
	vec3 vertexPos =vec3(float(boundingbox_size.x/cubeGridDims.x*x+min_pos.x),float(boundingbox_size.y/cubeGridDims.y*y+min_pos.y),float(boundingbox_size.z/cubeGridDims.z*z+min_pos.z));
    
	return ControlNode(vertexPos, imageLoad(Vertices_tex, ivec3(x,y,z)).r);
}




void main(){
    ivec3 id = ivec3(gl_GlobalInvocationID);
    
	int x = id.x;
    int y = id.y;
    int z = id.z;
	
    int currentCubeID = indexCube(x, y, z);

    // determine the cube control nodes, i.e. the cube's vertices
    // front face vertices

    /*controlNodes[0] = getControlNode(x, y, z);
    controlNodes[1] = getControlNode(x, y+1, z);
    controlNodes[2] = getControlNode(x+1, y+1, z);
    controlNodes[3] = getControlNode(x+1, y, z);
    // back face, directly opposite to the previous one
    controlNodes[4] = getControlNode(x, y, z+1);
    controlNodes[5] = getControlNode(x, y+1, z+1);
    controlNodes[6] = getControlNode(x+1, y+1, z+1);
    controlNodes[7] = getControlNode(x+1, y, z+1);*/

	controlNodes[0] = getControlNode(x, y, z);
    controlNodes[1] = getControlNode(x, y+1, z);
    controlNodes[2] = getControlNode(x+1, y+1, z);
    controlNodes[3] = getControlNode(x+1, y, z);
    // back face, directly opposite to the previous one
    controlNodes[4] = getControlNode(x, y, z+1);
    controlNodes[5] = getControlNode(x, y+1, z+1);
    controlNodes[6] = getControlNode(x+1, y+1, z+1);
    controlNodes[7] = getControlNode(x+1, y, z+1);





    // calculate the configuration of the cube
    for(int i = 0; i < 8; ++i){
        if(controlNodes[i].value > surfaceLevel){
            configuration |= 1 << i;
        }
    }




    if(configuration != 0 && configuration != 255){ // useless to continue if there are no vertices in the cube
		edgeNodes[0]=vec3((controlNodes[0].pos.x+controlNodes[1].pos.x)/2,(controlNodes[0].pos.y+controlNodes[1].pos.y)/2,(controlNodes[0].pos.z+controlNodes[1].pos.z)/2);
        edgeNodes[1]=vec3((controlNodes[1].pos.x+controlNodes[2].pos.x)/2,(controlNodes[1].pos.y+controlNodes[2].pos.y)/2,(controlNodes[1].pos.z+controlNodes[2].pos.z)/2);
        edgeNodes[2]=vec3((controlNodes[2].pos.x+controlNodes[3].pos.x)/2,(controlNodes[2].pos.y+controlNodes[3].pos.y)/2,(controlNodes[2].pos.z+controlNodes[3].pos.z)/2);
        edgeNodes[3]=vec3((controlNodes[3].pos.x+controlNodes[0].pos.x)/2,(controlNodes[3].pos.y+controlNodes[0].pos.y)/2,(controlNodes[3].pos.z+controlNodes[0].pos.z)/2);
        edgeNodes[4]=vec3((controlNodes[4].pos.x+controlNodes[5].pos.x)/2,(controlNodes[4].pos.y+controlNodes[5].pos.y)/2,(controlNodes[4].pos.z+controlNodes[5].pos.z)/2);
        edgeNodes[5]=vec3((controlNodes[5].pos.x+controlNodes[6].pos.x)/2,(controlNodes[5].pos.y+controlNodes[6].pos.y)/2,(controlNodes[5].pos.z+controlNodes[6].pos.z)/2);
        edgeNodes[6]=vec3((controlNodes[6].pos.x+controlNodes[7].pos.x)/2,(controlNodes[6].pos.y+controlNodes[7].pos.y)/2,(controlNodes[6].pos.z+controlNodes[7].pos.z)/2);
        edgeNodes[7]=vec3((controlNodes[7].pos.x+controlNodes[4].pos.x)/2,(controlNodes[7].pos.y+controlNodes[4].pos.y)/2,(controlNodes[7].pos.z+controlNodes[4].pos.z)/2);
        edgeNodes[8]=vec3((controlNodes[0].pos.x+controlNodes[4].pos.x)/2,(controlNodes[0].pos.y+controlNodes[4].pos.y)/2,(controlNodes[0].pos.z+controlNodes[4].pos.z)/2);
        edgeNodes[9]=vec3((controlNodes[1].pos.x+controlNodes[5].pos.x)/2,(controlNodes[1].pos.y+controlNodes[5].pos.y)/2,(controlNodes[1].pos.z+controlNodes[5].pos.z)/2);
        edgeNodes[10]=vec3((controlNodes[2].pos.x+controlNodes[6].pos.x)/2,(controlNodes[2].pos.y+controlNodes[6].pos.y)/2,(controlNodes[2].pos.z+controlNodes[6].pos.z)/2);
        edgeNodes[11]=vec3((controlNodes[3].pos.x+controlNodes[7].pos.x)/2,(controlNodes[3].pos.y+controlNodes[7].pos.y)/2,(controlNodes[3].pos.z+controlNodes[7].pos.z)/2);
        
    
    
	
	int triConfigIndex = configuration;
	int cubeIndex=indexCube( x, y, z );

	for(int i = 0; triTable[triConfigIndex][i] != -1; i += 3){

		vec3 vertA = edgeNodes[ triTable[triConfigIndex][i]];
        vec3 vertB = edgeNodes[ triTable[triConfigIndex][i+1]];
        vec3 vertC = edgeNodes[ triTable[triConfigIndex][i+2]];


		/*
        // Append the triangle in the triangles buffer
        int triIndex = atomicAdd(triCount, 1);
        triangles[triIndex] = Triangle(vertA, vertB, vertC);
		*/
		int triIndex = atomicAdd(triCount, 1);
		
	

/*
		float p=float(currentCubeID);
		float p2=float(triConfigIndex);

		triangles[triIndex*9]=p;
		triangles[triIndex*9+1]=p2;
		triangles[triIndex*9+2]=imageLoad(Vertices_tex, ivec3(x,y,z)).r;
		triangles[triIndex*9+3]=imageLoad(Vertices_tex, ivec3(x,y+1,z)).r;
		triangles[triIndex*9+4]=imageLoad(Vertices_tex, ivec3(x+1,y+1,z)).r;
		triangles[triIndex*9+5]=imageLoad(Vertices_tex, ivec3(x+1,y,z)).r;
		triangles[triIndex*9+6]=imageLoad(Vertices_tex, ivec3(x,y,z+1)).r;
		triangles[triIndex*9+7]=imageLoad(Vertices_tex, ivec3(x,y+1,z+1)).r;
		triangles[triIndex*9+8]=imageLoad(Vertices_tex, ivec3(x+1,y+1,z+1)).r;
*/
	
		triangles[triIndex*9]=vertA.x;
		triangles[triIndex*9+1]=vertA.y;
		triangles[triIndex*9+2]=vertA.z;
		triangles[triIndex*9+3]=vertB.x;
		triangles[triIndex*9+4]=vertB.y;
		triangles[triIndex*9+5]=vertB.z;
		triangles[triIndex*9+6]=vertC.x;
		triangles[triIndex*9+7]=vertC.y;
		triangles[triIndex*9+8]=vertC.z;
		
		


    }}
	/*
	else{
	int triIndex = atomicAdd(triCount, 1);
		int triConfigIndex = configuration;
		float p=float(currentCubeID);
		float p2=float(triConfigIndex);
		//triangles[triIndex*9]=p;
		//triangles[triIndex*9+1]=p2;
		//triangles[triIndex*9+2]=float(controlNodes[0].pos.x);
		//triangles[triIndex*9+3]=float(controlNodes[0].pos.y);
		//triangles[triIndex*9+4]=float(controlNodes[0].pos.z);

		triangles[triIndex*9]=p;
		triangles[triIndex*9+1]=p2;
		triangles[triIndex*9+2]=controlNodes[7].value;
		triangles[triIndex*9+3]=controlNodes[0].value;
		triangles[triIndex*9+4]=controlNodes[2].value;
		triangles[triIndex*9+5]=controlNodes[3].value;
		triangles[triIndex*9+6]=controlNodes[4].value;
		triangles[triIndex*9+7]=controlNodes[5].value;
		triangles[triIndex*9+8]=controlNodes[6].value;
	
	
	}
	*/
	
	
	
}