#version 440

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 2, r32f) uniform readonly image3D V_tex;//load the info of voxels
layout(binding = 3, rgba32f) uniform writeonly image3D V_new_tex;//store the info of inside voxels

uniform vec3 min_bbox;
uniform vec3 max_bbox;


uniform float voxel_size;
uniform uvec3 resolution;

uniform vec3 cam_pos1;
uniform vec3 cam_pos2;
uniform vec3 cam_pos3;

struct point_in_voxel{
ivec3 id;
vec3 pos;
int inside;
};

vec3 get_center_pos(ivec3 VoxelID) {
vec3 vc=min_bbox+vec3((VoxelID.x+1)*voxel_size-voxel_size/2,(VoxelID.y+1)*voxel_size-voxel_size/2,(VoxelID.z+1)*voxel_size-voxel_size/2);
return  vc;
	
}

//use when_eq to avoid "if" expression
float when_eq(float x,float y){
	return 1.0-abs(sign(x-y));
}
//find the next point through the ray in the boundingbox
point_in_voxel next_point(vec3 ray,point_in_voxel p)
{

	p.id.x=p.id.x+int(sign(ray.x) * when_eq(p.pos.x,0));
	p.pos.x=p.pos.x+voxel_size * when_eq(p.pos.x,0);

	p.id.y=p.id.y+int(sign(ray.y)*when_eq(p.pos.y,0));
	p.pos.y=p.pos.y+voxel_size*when_eq(p.pos.y,0);
	
	p.id.z=p.id.z+int(sign(ray.z)*when_eq(p.pos.z,0));
	p.pos.z=p.pos.z+voxel_size*when_eq(p.pos.z,0);


	if(p.id.x<0||p.id.y<0||p.id.z<0|| p.id.x== resolution.x|| p.id.y == resolution.y|| p.id.z== resolution.z)
		return p;

	float time1,time2,time3;

	time1=p.pos.x/abs(ray.x);
	time2=p.pos.y/abs(ray.y);
	time3=p.pos.z/abs(ray.z);

	float min_time = min(time1,time2);
	min_time=min(min_time,time3);

	if(min_time==time1){
		p.pos.x=0;
		p.pos.y=p.pos.y-time1*abs(ray.y);
		p.pos.z=p.pos.z-time1*abs(ray.z);		
	
	}else if(min_time==time2){
		p.pos.y=0;
		p.pos.x=p.pos.x-time2*abs(ray.x);
		p.pos.z=p.pos.z-time2*abs(ray.z);	
	}else if(min_time==time3){
		p.pos.z=0;
		p.pos.x=p.pos.x-time3*abs(ray.x);
		p.pos.y=p.pos.y-time3*abs(ray.y);	
	}

	//p.inside=(p.inside+int(when_eq(imageLoad(V_tex, p.id).r,1)))%2;
	if(imageLoad(V_tex, p.id).r==1)
		p.inside=1;
	return p;

}


void main() {

    // The voxel coordinates of this thread
    ivec3 idx = ivec3(gl_GlobalInvocationID);
	


	if(imageLoad(V_tex, idx).r==1){
	

		imageStore(V_new_tex, idx, vec4(1,0,0,0));
		
	}else{

	
	vec3 voxelpos=get_center_pos(idx);
	//three rays from current voxel to cameras
	vec3 voxel_cam_ray_1 = cam_pos1 - voxelpos;
	vec3 voxel_cam_ray_2 = cam_pos2 - voxelpos;
	vec3 voxel_cam_ray_3 = cam_pos3 - voxelpos;
	
	//seperately calculate the voxels that each ray go through
	point_in_voxel pv1;
	pv1.id=idx;
	pv1.pos=vec3(voxel_size/2,voxel_size/2,voxel_size/2);
	pv1.inside=0;
	
	
	point_in_voxel pv2;
	pv2.id=idx;
	pv2.pos=vec3(voxel_size/2,voxel_size/2,voxel_size/2);
	pv2.inside=0;

	point_in_voxel pv3;
	pv3.id=idx;
	pv3.pos=vec3(voxel_size/2,voxel_size/2,voxel_size/2);
	pv3.inside=0;
	
	//if ray arrives the boundary,stop
	while (pv1.id.x>=0 && pv1.id.y>=0 && pv1.id.z>=0 && pv1.id.x< resolution.x && pv1.id.y< resolution.y && pv1.id.z< resolution.z && pv1.inside==0 ){
	
	pv1=next_point( voxel_cam_ray_1,pv1);
	
	}
	
	while (pv2.id.x>=0 && pv2.id.y>=0 && pv2.id.z>=0 && pv2.id.x< resolution.x && pv2.id.y< resolution.y && pv2.id.z< resolution.z && pv2.inside==0 && pv1.inside==1){
	
	pv2=next_point( voxel_cam_ray_2,pv2);
	
	}

	while (pv3.id.x>=0 && pv3.id.y>=0 && pv3.id.z>=0 && pv3.id.x< resolution.x && pv3.id.y< resolution.y && pv3.id.z< resolution.z && pv3.inside==0&& pv2.inside==1 && pv1.inside==1){
	
	pv3=next_point( voxel_cam_ray_3,pv3);
	
	}

	if((pv1.inside+pv2.inside+pv3.inside)==3)
		imageStore(V_new_tex, idx, vec4(2,0,0,0));
	else
		imageStore(V_new_tex, idx, vec4(0,0,0,0));

	}



	/*
	//store the info of current calcaulated voxel
	if(imageLoad(V_tex, idx).r==1){
	


	



		imageStore(V_new_tex, idx, vec4(1,pv2.id));
		
	}else if((pv1.inside+pv2.inside+pv3.inside)==3)
		imageStore(V_new_tex, idx, vec4(2,pv2.id));
	else
		imageStore(V_new_tex, idx, vec4(0,pv2.id));
	*/			
}
