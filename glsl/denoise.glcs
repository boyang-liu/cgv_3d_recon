#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, r32f) uniform readonly image3D P_tex;
//layout(binding = 1, r32f) uniform writeonly image3D init_V_tex;



layout (std430, binding = 1) buffer CountBuffer{
    int cnts[];
};

layout(std430, binding = 2) readonly buffer V1Buffer {
	int V1[];
};

uniform uvec3 resolution;
uniform int threshold;
uniform int range;



ivec3 get_index(int V_ID , uvec3 V_resolution) {
int VoxelID=V_ID+1;
int x,y,z;
z=int(floor(VoxelID/(V_resolution.x*V_resolution.y)));
y=int(floor((VoxelID-(V_resolution.x*V_resolution.y)*z)/V_resolution.x));
x=int(VoxelID-(V_resolution.x*V_resolution.y)*z-V_resolution.x*y);
ivec3 ind=ivec3(x-1,y-1,z-1);
return  ind;
	
}



int denoise(ivec3 VoxelID){

int count=0;

int thr2=int(ceil(threshold/2));
int thr1=1-thr2;
for(int i=thr1;i<thr2;i++)
	for(int j=thr1;j<thr2;j++)
		for(int k=thr1;k<thr2;k++)
		{
		if((VoxelID.x+i)<resolution.x && (VoxelID.x+i)>=0 &&
		(VoxelID.y+j)<resolution.y && (VoxelID.y+j)>=0 &&
		(VoxelID.z+k)<resolution.z && (VoxelID.z+k)>=0
		)
		count=count+int(imageLoad(P_tex, ivec3((VoxelID.x+i),(VoxelID.y+j),(VoxelID.z+k))).r);
	
		}
if( count>threshold )
	{return 1;}
else 
	{return 0;}
}





void main() {

	
    // The voxel coordinates of this thread

	ivec3 current_V = ivec3(gl_GlobalInvocationID);
	int current_V_id = V1[current_V.x];
	ivec3 idx=get_index(current_V_id,resolution);


	//int index = get_index(idx,resolution);
		

	atomicAdd(cnts[current_V_id],denoise(idx) );
	
		
}
