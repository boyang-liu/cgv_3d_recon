#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


layout (std430, binding = 9) buffer cubesBuffer
{
    float cubes[];
};

layout (std430, binding = 11) buffer denoisedcubesBuffer
{
    float denoisedcubes[];
};



uniform ivec3 cubeGridDims;
uniform int threshold;
uniform int range;






int indexCube(int x, int y, int z){
    return (x + cubeGridDims.x * y + cubeGridDims.x * cubeGridDims.y * z) ;
}

float denoise(ivec3 VoxelID){

float value=0;

int thr2=int(ceil(threshold/2));
int thr1=1-thr2;
for(int i=thr1;i<thr2;i++)
	for(int j=thr1;j<thr2;j++)
		for(int k=thr1;k<thr2;k++)
		{
		if((VoxelID.x+i)<cubeGridDims.x && (VoxelID.x+i)>=0 &&
		(VoxelID.y+j)<cubeGridDims.y && (VoxelID.y+j)>=0 &&
		(VoxelID.z+k)<cubeGridDims.z && (VoxelID.z+k)>=0
		)
		value=value+cubes[indexCube((VoxelID.x+i),(VoxelID.y+j),(VoxelID.z+k))];
	
		}
if( value >= threshold )
	return 1.0;
else 
	return 0;
}





void main() {

	
    // The voxel coordinates of this thread
	

	ivec3 id = ivec3(gl_GlobalInvocationID);
    
	int x = id.x;
    int y = id.y;
    int z = id.z;
	

    int currentCubeID = indexCube(x, y, z);
	
	if(cubes[currentCubeID]!=0)	
		denoisedcubes[currentCubeID] = denoise(ivec3(x,y,z));	
	else 
		denoisedcubes[currentCubeID] = 0;	
	

	//denoisedcubes[currentCubeID ] = 0.5;
}
